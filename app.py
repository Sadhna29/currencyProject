from flask import Flask, flash, jsonify, request, render_template, redirect, url_for, session
import sqlite3
import requests
import os
from werkzeug.security import generate_password_hash, check_password_hash
import datetime
from decimal import Decimal, InvalidOperation

app = Flask(__name__)
DB_FILE = "db.sqlite3"

if os.environ.get('FLASK_SECRET_KEY'):
    app.secret_key = os.environ.get('FLASK_SECRET_KEY')
else:
    # dfallback for development if environment variable isn't set.
    app.secret_key = b'_5#y2L"F4Q8z\n\xec]/'
    print("WARNING: FLASK_SECRET_KEY environment variable not set. Sessions will not persist across restarts.")


# configure API
API_KEY = os.environ.get('EXCHANGE_RATE_API_KEY', '53d96b6b69585529137b8408')
API_BASE_URL = f'https://v6.exchangerate-api.com/v6/{API_KEY}'

# max allowed amount for conversions to prevent excessively large numbers
# Using Decimal for this comparison as well to maintain precision.
MAX_AMOUNT_VALUE = Decimal('1000000000000000000000000.00') # Example: 10^24, adjust as needed

# currency symbols generated by AI
CURRENCY_SYMBOLS = {
    'AED': 'د.إ', 'AFN': '؋', 'ALL': 'L', 'AMD': '֏', 'ANG': 'ƒ', 'AOA': 'Kz', 'ARS': '$', 'AUD': '$',
    'AWG': 'ƒ', 'AZN': '₼', 'BAM': 'KM', 'BBD': '$', 'BDT': '৳', 'BGN': 'лв', 'BHD': '.د.ب', 'BIF': 'FBu',
    'BMD': '$', 'BND': '$', 'BOB': 'Bs.', 'BRL': 'R$', 'BSD': '$', 'BTN': 'Nu.', 'BWP': 'P', 'BYN': 'Br',
    'BZD': 'BZ$', 'CAD': '$', 'CDF': 'FC', 'CHF': 'CHF', 'CLP': '$', 'CNY': '¥', 'COP': '$', 'CRC': '₡',
    'CUP': '₱', 'CVE': '$', 'CZK': 'Kč', 'DJF': 'Fdj', 'DKK': 'kr.', 'DOP': 'RD$', 'DZD': 'د.ج', 'EGP': '£',
    'ERN': 'Nfk', 'ETB': 'Br', 'EUR': '€', 'FJD': '$', 'FKP': '£', 'FOK': 'kr.', # Faroese Króna (often uses DKK symbol)
    'GBP': '£', 'GEL': '₾', 'GGP': '£', 'GHS': '₵', 'GIP': '£', 'GMD': 'D', 'GNF': 'FG', 'GTQ': 'Q',
    'GYD': '$', 'HKD': '$', 'HNL': 'L', 'HRK': 'kn', 'HTG': 'G', 'HUF': 'Ft', 'IDR': 'Rp', 'ILS': '₪',
    'IMP': '£', 'INR': '₹', 'IQD': 'ع.د', 'IRR': '﷼', 'ISK': 'kr', 'JEP': '£', 'JMD': 'J$', 'JOD': 'د.ا',
    'JPY': '¥', 'KES': 'KSh', 'KGS': 'сом', 'KHR': '៛', 'KID': '$', # Kiribati Dollar (often uses AUD symbol)
    'KMF': 'CF', 'KRW': '₩', 'KWD': 'د.ك', 'KYD': '$', 'KZT': '₸', 'LAK': '₭', 'LBP': 'ل.ل', 'LKR': 'Rs',
    'LRD': '$', 'LSL': 'L', 'LYD': 'ل.د', 'MAD': 'د.م.', 'MDL': 'L', 'MGA': 'Ar', 'MKD': 'ден', 'MMK': 'Ks',
    'MNT': '₮', 'MOP': 'P', 'MRU': 'UM', 'MUR': '₨', 'MVR': 'Rf', 'MWK': 'MK', 'MXN': '$', 'MYR': 'RM',
    'MZN': 'MT', 'NAD': '$', 'NGN': '₦', 'NIO': 'C$', 'NOK': 'kr', 'NPR': '₨', 'NZD': '$', 'OMR': 'ر.ع.',
    'PAB': 'B/.', 'PEN': 'S/.', 'PGK': 'K', 'PHP': '₱', 'PKR': '₨', 'PLN': 'zł', 'PYG': '₲', 'QAR': 'ر.ق',
    'RON': 'lei', 'RSD': 'дин.', 'RUB': '₽', 'RWF': 'FRw', 'SAR': 'ر.س', 'SBD': '$', 'SCR': '₨', 'SDG': 'ج.س.',
    'SEK': 'kr', 'SGD': '$', 'SHP': '£', 'SLE': 'Le', 'SOS': 'Sh', 'SRD': '$', 'SSP': 'SS£', 'STN': 'Db',
    'SYP': '£', 'SZL': 'E', 'THB': '฿', 'TJS': 'ЅМ', 'TMT': 'm', 'TND': 'د.ت', 'TOP': 'T$', 'TRY': '₺',
    'TTD': 'TT$', 'TVD': '$', # Tuvaluan Dollar (often uses AUD symbol)
    'TWD': 'NT$', 'TZS': 'Sh', 'UAH': '₴', 'UGX': 'USh', 'USD': '$', 'UYU': '$U', 'UZS': 'сум', 'VES': 'Bs',
    'VND': '₫', 'VUV': 'Vt', 'WST': 'T', 'XAF': 'FCFA', 'XCD': '$', 'XDR': 'SDR', # Special Drawing Rights, no single symbol
    'XOF': 'FCFA', 'XPF': '₣', 'YER': '﷼', 'ZAR': 'R', 'ZMW': 'ZK', 'ZWL': 'Z$'
}

def get_graph_data(base_currency, target_currency):
    conn = None
    try:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        # fetch rates for base currency
        cursor.execute(f"SELECT rate2021, rate2022, rate2023, rate2024, rate2025 FROM currency_data WHERE base_currency = ?", (base_currency,))
        base_rates = cursor.fetchone()

        # fetch rates for the target currency
        cursor.execute(f"SELECT rate2021, rate2022, rate2023, rate2024, rate2025 FROM currency_data WHERE base_currency = ?", (target_currency,))
        target_rates = cursor.fetchone()

        if not base_rates or not target_rates:
            print(f"Historical data not found for {base_currency} or {target_currency}.")
            flash("No data found for graph.", "failure")
            return [] # rteurn empty list if data is missing

        # calculate the ratio (base_rate / target_rate) for each year
        graph_y_values = []
        for i in range(len(base_rates)):
            if target_rates[i] != 0:
                graph_y_values.append(float(target_rates[i]) / float(base_rates[i]))
            else:
                graph_y_values.append(0) # handle as None/Infinity depending on desired chart behavior

        return graph_y_values

    except sqlite3.Error as e:
        print(f"Database error fetching graph data: {e}")
        return []
    except Exception as e:
        print(f"An unexpected error occurred in get_graph_data: {e}")
        return []
    finally:
        if conn:
            conn.close()


def get_supported_currencies_from_api():
    """Fetches supported currency codes from the ExchangeRate-API."""
    try:
        response = requests.get(f'{API_BASE_URL}/codes')
        response.raise_for_status() # Raises HTTPError for bad responses (4xx or 5xx)
        data = response.json()
        if data.get('result') == 'success' and 'supported_codes' in data:
            # The API returns a list of lists, e.g., [["USD", "United States Dollar"], ...]
            return [code[0] for code in data['supported_codes']]
        else:
            print("Error: Could not fetch supported currency codes from API. Response:", data)
            return [] # Return empty list if API response is not as expected
    except requests.exceptions.RequestException as e:
        print(f"Network or API error fetching supported currencies: {e}")
        return [] # Return empty list on error
    except Exception as e:
        print(f"An unexpected error occurred while fetching supported currencies: {e}")
        return [] # Return empty list on unexpected error

# Populate SUPPORTED_CURRENCIES at startup
# Fallback to a small default set if API call fails
initial_supported_currencies = get_supported_currencies_from_api()
if initial_supported_currencies:
    SUPPORTED_CURRENCIES = initial_supported_currencies
else:
    # A small, reliable fallback set for development if API is unreachable
    SUPPORTED_CURRENCIES = ['USD', 'EUR', 'GBP', 'JPY', 'CAD']
    print("Falling back to default supported currencies due to API fetch failure.")

@app.route("/register", methods=["GET", "POST"])
def register():
    if request.method == "POST":
        username = request.form.get("username")
        password = request.form.get("password")
        security_answer = request.form.get("security_answer")

        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        # Check if username already exists
        cursor.execute("SELECT * FROM logins WHERE username = ?", (username,))
        existing_user = cursor.fetchone()
        if existing_user:
            flash("Username already exists. Please choose a different one.", "danger")
            conn.close()
            return render_template("register.html")

        if not username or not password or not security_answer:
            flash("Username, password and security_answer cannot be empty.", "danger")
            conn.close()
            return render_template("register.html")

        if len(password) < 8:
            flash("Password needs to be at least 8 characters long.", "danger")
            conn.close()
            return render_template("register.html")

        hashed_password = generate_password_hash(password)

        try:
            cursor.execute("INSERT INTO logins (username, password, security_answer) VALUES (?, ?, ?)",
                           (username, hashed_password, security_answer)
                           )
            conn.commit()
            flash("Registration successful! You can now log in.", "success")
            return redirect(url_for("login"))
        except sqlite3.Error as e:
            flash(f"Registration failed: {e}", "danger")
            print(f"Database error during registration: {e}")
            return render_template("register.html")
        finally:
            conn.close()

    return render_template("register.html")

@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        username = request.form.get("username")
        password = request.form.get("password")

        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        cursor.execute("SELECT password FROM logins WHERE username = ?", (username,))
        user_data = cursor.fetchone()
        conn.close()

        if user_data and check_password_hash(user_data[0], password):
            session['username'] = username # Store username in session
            flash("Login successful!", "success")
            return redirect(url_for("index"))
        else:
            flash("Invalid username or password.", "danger")
            return render_template("login.html")
    return render_template("login.html")

@app.route("/forgot_password", methods=["GET", "POST"])
def forgot_password():
    if request.method == "POST":
        username = request.form.get("username")
        security_answer = request.form.get("security_answer")
        new_password = request.form.get("new_password")

        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        # Step 1: Verify username and security answer
        cursor.execute("SELECT security_answer FROM logins WHERE username = ?", (username,))
        user_data = cursor.fetchone()

        if user_data:
            stored_security_answer = user_data[0]
            if stored_security_answer == security_answer:
                # Step 2: Validate new password
                if not new_password or len(new_password) < 8:
                    flash("New password needs to be at least 8 characters long.", "danger")
                    conn.close()
                    return render_template("forgot_password.html")

                # Step 3: Update password
                hashed_new_password = generate_password_hash(new_password)
                try:
                    cursor.execute("UPDATE logins SET password = ? WHERE username = ?",
                                   (hashed_new_password, username))
                    conn.commit()
                    flash("Password reset successfully! You can now log in with your new password.", "success")
                    return redirect(url_for("login"))
                except sqlite3.Error as e:
                    flash(f"Failed to update password: {e}", "danger")
                    print(f"Database error during password update: {e}")
            else:
                flash("Invalid security answer.", "danger")
        else:
            flash("Username not found.", "danger")
        
        conn.close() # Close connection after all operations

    return render_template("forgot_password.html")


@app.route("/logout")
def logout():
    session.pop('username', None)
    flash("You have been logged out.", "info")
    return redirect(url_for("login"))

def fetch_symbol(target_currency):
    return CURRENCY_SYMBOLS.get(target_currency)

def add_to_history(base_currency, target_currency, amount, username):
    """Adds a successful conversion to the user's history."""
    if username:
        conn = None
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            # Store amount as REAL for history, assuming SQLite's REAL handles sufficient precision for normal use cases
            cursor.execute(
                "INSERT INTO history (username, base, target, amount, timestamp) VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)",
                (username, base_currency, target_currency, float(amount)) # Convert Decimal to float for REAL column
            )
            conn.commit()
            flash("Conversion saved to history!", "info")
        except sqlite3.Error as e:
            flash(f"Error saving conversion to history: {e}", "danger")
            print(f"Database error saving history: {e}")
        finally:
            if conn:
                conn.close()
    # If username is None, the flash message is handled in the index route now.

def add_to_error_log(username, base_currency, target_currency, amount, error_message):
    """Logs an error event to the error_log table."""
    conn = None
    try:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        # Store amount as TEXT in error_log to preserve original large number string
        cursor.execute(
            "INSERT INTO error_log (username, base_currency, target_currency, amount, error_message, timestamp) VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)",
            (username, base_currency, target_currency, str(amount), error_message) # Store amount as string
        )
        conn.commit()
        print(f"Error logged for {username or 'Guest'}: {error_message} (Amount: {amount})")
    except sqlite3.Error as e:
        print(f"Failed to log error to DB: {e}")
    finally:
        if conn:
            conn.close()


@app.route("/history")
def history():
    username = session.get('username')
    if not username:
        flash("Please log in to view your conversion history.", "warning")
        return redirect(url_for('login'))

    conn = None
    history_records = []
    try:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute(
            "SELECT base, target, amount, timestamp FROM history WHERE username = ? ORDER BY timestamp DESC",
            (username,)
        )
        history_records = cursor.fetchall()
    except sqlite3.Error as e:
        flash(f"Database error fetching history: {e}", "danger")
        print(f"Database error: {e}")
    finally:
        if conn:
            conn.close()

    return render_template("history.html", history_records=history_records, logged_in_username=username)

@app.route("/error")
def error_log():
    username = session.get('username')
    if not username:
        flash("Please log in to view the error log.", "warning")
        return redirect(url_for('login'))

    conn = None
    error_records = []
    try:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        # Fetch all columns for the error log, including error_message
        # CORRECTED COLUMN NAMES: base_currency, target_currency
        cursor.execute(
            "SELECT base_currency, target_currency, amount, error_message, timestamp FROM error_log WHERE username = ? ORDER BY timestamp DESC",
            (username,)
        )
        error_records = cursor.fetchall()
    except sqlite3.Error as e:
        flash(f"Database error fetching error log: {e}", "danger")
        print(f"Database error fetching error log: {e}")
    finally:
        if conn:
            conn.close()

    return render_template("error.html", error_records=error_records, logged_in_username=username)


#calculate the amount in the target currency
def calculate(amount_decimal, rate):
    # Use Decimal for calculations to maintain precision for large numbers
    return amount_decimal * Decimal(str(rate))

#fetch exchange rate between the base and target currency
def get_exchange_rate(base_currency, target_currency):
    if base_currency == target_currency:
        return Decimal('1.0'), None # Return rate as Decimal and no error

    try:
        response = requests.get(f'{API_BASE_URL}/latest/{base_currency}')
        response.raise_for_status() # raises a HTTPError for bad responses (4xx or 5xx)
        data = response.json()

        if data.get('result') == 'error':
            error_msg = data.get('error-type', 'Unknown API Error')
            return None, f"API Error: {error_msg}" # Return None for rate and the error message

        conversion_rates = data.get('conversion_rates')
        if conversion_rates and target_currency in conversion_rates:
            # Convert rate to Decimal immediately for precision
            return Decimal(str(conversion_rates[target_currency])), None # Return rate and no error
        else:
            error_msg = f"Target currency {target_currency} not found in API response for {base_currency}."
            print(f"Error: {error_msg}")
            return None, error_msg # Indicate no rate found with error message

    except requests.exceptions.HTTPError as http_err:
        error_msg = f"HTTP error occurred while fetching rate: {http_err} (Status: {http_err.response.status_code})"
        flash(f"HTTP error occurred while fetching rate: {http_err}", "danger")
        print(f"HTTP error occurred: {http_err}")
        return None, error_msg # Indicate error
    except requests.exceptions.ConnectionError as conn_err:
        error_msg = f"Network error: Could not connect to exchange rate API: {conn_err}"
        flash(f"Network error: Could not connect to exchange rate API.", "danger")
        print(f"Connection error: {conn_err}")
        return None, error_msg # Indicate error
    except Exception as err:
        error_msg = f"An unexpected error occurred: {err}"
        flash(f"An unexpected error occurred: {err}", "danger")
        print(f"Other error occurred: {err}")
        return None, error_msg # Indicate error

@app.route('/', methods = ('GET', 'POST'))
def index():
    #default values
    result = Decimal('0.00') # Initialize result as Decimal
    rate = None
    api_error_message = None # To store error message from API call
    target_currency_symbol = CURRENCY_SYMBOLS.get('GBP', '£')
    selected_base_currency = 'GBP'
    selected_target_currency = 'GBP'
    # Default input amount as a string to avoid precision loss early
    input_amount_str = '1.00'
    input_amount_decimal = Decimal('1.00') # For internal calculations
    logged_in_username = session.get('username')

    graph_y_values = []
    graph_x_values = ["2021", "2022", "2023", "2024", "2025"] # Define X-axis labels


    if request.method == 'POST':
        selected_base_currency = request.form.get('base_currency')
        selected_target_currency = request.form.get('target_currency')
        input_amount_str = request.form.get('amount') # Get as string
        amount_valid = True # Flag to track if the amount input is valid

        try:
            # Attempt to convert to Decimal for precise internal handling
            input_amount_decimal = Decimal(input_amount_str)

            if input_amount_decimal <= 0: # Amount must be positive
                flash("Amount must be a positive number.", "danger")
                input_amount_decimal = Decimal('0.00')
                amount_valid = False
                api_error_message = "Invalid amount entered (must be positive)."
            elif input_amount_decimal > MAX_AMOUNT_VALUE: # Check against max value
                flash(f"Amount exceeds maximum allowed value of {MAX_AMOUNT_VALUE:,.2f}.", "danger")
                input_amount_decimal = Decimal('0.00')
                amount_valid = False
                api_error_message = f"Amount exceeds max value ({MAX_AMOUNT_VALUE})."

        except InvalidOperation:
            flash("Invalid amount entered. Please enter a valid number.", "danger")
            input_amount_decimal = Decimal('0.00')
            amount_valid = False
            api_error_message = "Invalid amount entered (not a valid number format)."
        except Exception as e:
            flash(f"An unexpected error occurred with the amount: {e}", "danger")
            input_amount_decimal = Decimal('0.00')
            amount_valid = False
            api_error_message = f"Unexpected error processing amount: {e}"


        # Only attempt to get the exchange rate if the amount input was valid
        if amount_valid:
            rate, api_error_message = get_exchange_rate(selected_base_currency, selected_target_currency)

    target_currency_symbol = fetch_symbol(selected_target_currency)


    graph_y_values = get_graph_data(selected_base_currency, selected_target_currency)

    # Fetch initial graph data on GET request if no currencies are selected yet or as defaults
    if request.method == 'GET':
        # Default currencies for graph if not explicitly set by POST
        graph_y_values = get_graph_data(selected_base_currency, selected_target_currency)


    # --- Only calculate and add to history if a valid rate was obtained ---
    if rate is not None:
        result = calculate(input_amount_decimal, rate)
        # Only save to history if conversion was successful (rate is not None implies amount_valid)
        if logged_in_username:
            # Pass the original Decimal value to add_to_history
            add_to_history(selected_base_currency, selected_target_currency, input_amount_decimal, logged_in_username)
        else:
            flash("Login to save your conversions to history.", "info")
    else:
        result = Decimal('0.00')   # No rate found due to API error, invalid input, or direct same-currency conversion
        # Log the error if conversion failed and there's a specific message
        if api_error_message:
            # For logging, pass the string representation of the original input
            add_to_error_log(logged_in_username, selected_base_currency, selected_target_currency, input_amount_str, api_error_message)

    print(f"Graph Y Values: {graph_y_values}")
    print(f"Graph X Values: {graph_x_values}") # Also check X values

    return render_template(
        'index.html',
        result=f"{result:,.2f}", # Format result for display with commas
        selected_base_currency = selected_base_currency,
        selected_target_currency = selected_target_currency,
        input_amount=input_amount_str, # Pass the string back to the input field
        supported_currencies = SUPPORTED_CURRENCIES,
        symbol = target_currency_symbol,
        logged_in_username=logged_in_username,
        graph_x_values=graph_x_values, # Pass X-axis labels
        graph_y_values=graph_y_values # Pass calculated Y-axis values
    )


if __name__ == '__main__':
    # Ensure database and tables are created on startup
    app.run(debug=True)
